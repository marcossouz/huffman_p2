Feature orientation is an emerging paradigm of software development. It supports the automatic generation of large-scale software systems from a set of units of functionality called features. The key idea of feature-oriented software development (FOSD) is to emphasize the similarities of a family of software systems for a given application domain (e.g., database systems, banking software, text processing systems) with the goal of reusing software artifacts among the family members. Features distinguish different members of the family. A feature is a unit of functionality that satisfies a requirement, represents a design decision, and provides a potential configuration option. A  challenge in FOSD is that a feature does not map cleanly to an isolated module of code. Rather it may affect (cut across) many components/artifacts of a software system. Furthermore, the decomposition of a software system into its features gives rise to a combinatorial explosion of possible feature combinations and interactions. Research on FOSD has shown that the concept of features pervades all phases of the software life cycle and requires a proper treatmebht in terms of analysis, design, and programming techniques, methods, languages, and tools, as well as formalisms and theory. Keynote: There has been little research on interfaces for features. In FOSD, work on feature modularity has focused on features as a criterion for system decomposition and assembly, such as in product-line development. The concept of feature modularity pertains mainly to cohesion of features, including language or modelling support for coalescing all information related to a feature into a single module. There is no information hiding among features, and one feature can directly refer to or override the details of other features. Alternatively, in the feature-interaction literature, feature modules are black boxes that have inputs and outputs, but otherwise share no information with each other. Such extreme information hiding facilitates parallel and third-party development of features, but makes it very difficult to specify intended interactions, such as when a feature extends or overrides the behaviour of another feature, or when a feature ought to behave differently in the presence of other features. This talk proposes a compromise, in which features share a limited amount of information with each other by means of a feature interface. It looks at what such an interface might look like, and explores to what degree inter-feature references can be abstracted to references to features public interfaces.